
### 介绍
官方介绍:
协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。

### 基础用法
######  suspend关键字
suspend是协程的关键字，表示这个一个挂起函数，每一个被suspend饰的方法只能在suspend方法或者在协程中调用。

### 创建协程的几种方式
######  runBlocking(阻塞的)
定义:runBlocking在当前线程启动一个协程，协程任务会阻断当前线程，直到该协程执行结束。当协程执行结束之后，页面才会被显示出来。
```Java
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().name}")
        runBlocking {
            delay(5000)
            LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().name}")
        }
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().name}")
// 1637057051.857 : [TestActivity.kt, initView, 20]:Thread Name main
// 1637057056.894 : [TestActivity.kt, invokeSuspend, 23]:Thread Name main
// 1637057056.895 : [TestActivity.kt, initView, 25]:Thread Name main
```
根据输出可以看出，runBlocking会阻断当前线程，(在原线程内)执行完协程内容后，继续执行原线程

    delay是一个非阻塞式的挂起函数，它只会挂起当前协程，并不会影响其他协程的运行。注意，delay()函数只能在协程的作用域或其他挂起函数中调用。

###### lauch(非阻塞的)
定义:lauch 更多是用来发起一个无需结果的耗时任务，这个工作不需要返回结果。

我们看到launch函数中有3个参数context、start和block，同时都带有默认值，所以我们无需传递任何参数即可直接调用.
```Java
LogUtil.d(TAG, "launch before " + Thread.currentThread().name)
    GlobalScope.launch {
        delay(5000)
        LogUtil.d(TAG, "launch " + Thread.currentThread().name)
}
LogUtil.d(TAG, "launch after " + Thread.currentThread().name)
// 10:42:35.764 25559-25559 D/: [TestActivity.kt, initView, 31]:launch before main
// 10:42:35.810 25559-25559 D/: [TestActivity.kt, initView, 36]:launch after main
// 10:42:40.823 25559-25657 D/: [TestActivity.kt, invokeSuspend, 34]:launch DefaultDispatcher-worker-1
```
根据日志发现`launch()` 所启动的携程被挂起时，不会阻塞当前线程的进度。

###### async(非阻塞的)
定义: `async()`本质和`launch()`方法一样，只是sync 可以附带一个返回值，`async()`返回的是 Deferred 类型，Deferred 继承自 Job 接口，Job有的它都有，增加了一个方法 await ，这个方法接收的是 async 闭包中返回的值，并且 await() 方法是被`suspend()`修饰，所以只能在协程空间内调用

现在我们开启一个协程空间，在里面看下await方法
```java
LogUtil.d(TAG, "launch before ${Thread.currentThread().name}")
      GlobalScope.launch {
          LogUtil.d(TAG, "launch TreadName =  ${Thread.currentThread().name}")
          val async = async {
              delay(5000)
              LogUtil.d(TAG, "async TreadName = ${Thread.currentThread().name}")
              "async result"
          }
          LogUtil.d(TAG, "async after ")
          LogUtil.d(TAG, "async after , async result${async.await()} ")
          LogUtil.d(
              TAG, "async after TreadName = ${Thread.currentThread().name} , async = $async"
          )
      }
LogUtil.d(TAG, "launch after ${Thread.currentThread().name}")

 // 11:38:11.149 29567-29567 D: [TestActivity.kt, initView, 30]:launch before main
 // 11:38:11.193 29567-29567 D: [TestActivity.kt, initView, 44]:launch after main
 // 11:38:11.194 29567-29600 D: [TestActivity.kt, invokeSuspend, 32]:launch TreadName =  DefaultDispatcher-worker-1
 // 11:38:11.196 29567-29600 D: [TestActivity.kt, invokeSuspend, 38]:async after
 // 11:38:16.214 29567-29601 D: [TestActivity.kt, invokeSuspend, 35]:async TreadName = DefaultDispatcher-worker-2
 // 11:38:16.220 29567-29601 D: [TestActivity.kt, invokeSuspend, 39]:async after , async resultasync result
 // 11:38:16.224 29567-29601 D: [TestActivity.kt, invokeSuspend, 40]:async after TreadName = DefaultDispatcher-worker-2 , async = DeferredCoroutine{Completed}@53978f5

```
根据日志分析，我们发现，async()不会阻塞其他线程，并且可以通过await（）获取到方法其返回的对象，根据日志顺序发现，await()获取到协程内部的返回值后，才会继续执行。




- Dispatchers.Main
```java
GlobalScope.launch(Dispatchers.Main) {
    delay(500)
    textView.text = "初始化"
    LogUtil.d("runBlocking Main", "Thread Name ${Thread.currentThread().name}")
    LogUtil.d("runBlocking Main", "Thread Name ${Thread.currentThread().id}")
}
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().name}")
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().id}")
// 1637130831.565 22489-22489 D/runBlocking: [TestActivity.kt, initView, 32]:Thread Name main
// 1637130831.566 22489-22489 D/runBlocking: [TestActivity.kt, initView, 33]:Thread Name 2
// 1637130832.163 22489-22489 D/runBlocking Main: [TestActivity.kt, invokeSuspend, 29]:Thread Name main
// 1637130832.163 22489-22489 D/runBlocking Main: [TestActivity.kt, invokeSuspend, 30]:Thread Name 2
```
从日志来看launch 所创建的携程空间，不会阻塞主线程，携程被delay()挂起时，先执行了主线程主线程的代码后，等挂起时间到了就会执行携程空间逻辑，为了证明携程所在空间是主线程，我们在里面给一个View的文本赋值(众所周知,Android子现场不能更新UI)。

- Dispatchers.IO IO
```java
GlobalScope.launch(Dispatchers.IO) {
    delay(500)
    // textView.text = "初始化"
    LogUtil.d("runBlocking IO", "Thread Name ${Thread.currentThread().name}")
    LogUtil.d("runBlocking IO", "Thread Name ${Thread.currentThread().id}")
}
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().name}")
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().id}")
// 2021-11-17 16:18:43.865 1024-1024 D/runBlocking: [TestActivity.kt, initView, 33]:Thread Name main
// 2021-11-17 16:18:43.866 1024-1024 D/runBlocking: [TestActivity.kt, initView, 34]:Thread Name 2
// 2021-11-17 16:18:44.375 1024-1523 D/runBlocking IO: [TestActivity.kt, invokeSuspend, 29]:Thread Name DefaultDispatcher-worker-1
// 2021-11-17 16:18:44.375 1024-1523 D/runBlocking IO: [TestActivity.kt, invokeSuspend, 30]:Thread Name 7556
```
当我们使用IO作为上下文的时候，我们发现携程会被创建在一个新的线程中，在携程空间操作View对象的话，就会发生异常

- Dispatchers.Default 默认
```java
GlobalScope.launch(Dispatchers.Default) {
    delay(500)
    // textView.text = "初始化"
    LogUtil.d("runBlocking Default", "Thread Name ${Thread.currentThread().name}")
    LogUtil.d("runBlocking Default", "Thread Name ${Thread.currentThread().id}")
}
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().name}")
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().id}")
// 2021-11-17 16:18:43.865 1024-1024 D/runBlocking: [TestActivity.kt, initView, 33]:Thread Name main
// 2021-11-17 16:18:43.866 1024-1024 D/runBlocking: [TestActivity.kt, initView, 34]:Thread Name 2
// 2021-11-17 16:23:47.740 1907-2025 D/runBlocking Default: [TestActivity.kt, invokeSuspend, 29]:Thread Name DefaultDispatcher-worker-1
// 2021-11-17 16:23:47.740 1907-2025 D/runBlocking Default: [TestActivity.kt, invokeSuspend, 30]:Thread Name 7564
```
同IO，当我们使用IO作为上下文的时候，我们发现携程会被创建在一个新的线程中，在携程空间操作View对象的话，就会发生异常

- Dispatchers.Unconfined 未指定
```java
GlobalScope.launch(Dispatchers.Unconfined) {
    delay(500)
    // textView.text = "初始化"
    LogUtil.d("runBlocking Unconfined", "Thread Name ${Thread.currentThread().name}")
    LogUtil.d("runBlocking Unconfined", "Thread Name ${Thread.currentThread().id}")
}
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().name}")
LogUtil.d("runBlocking ", "Thread Name ${Thread.currentThread().id}")
// 2021-11-17 16:18:43.865 1024-1024 D/runBlocking: [TestActivity.kt, initView, 33]:Thread Name main
// 2021-11-17 16:18:43.866 1024-1024 D/runBlocking: [TestActivity.kt, initView, 34]:Thread Name 2
// 2021-11-17 16:30:06.115 3261-3300 D/Unconfined: [TestActivity.kt, invokeSuspend, 29]:Thread Name kotlinx.coroutines.DefaultExecutor
// 2021-11-17 16:30:06.116 3261-3300 D/Unconfined: [TestActivity.kt, invokeSuspend, 30]:Thread Name 7580
```
同IO，当我们使用IO作为上下文的时候，我们发现携程会被创建在一个新的线程中，在携程空间操作View对象的话，就会发生异常







### 参考资料
- [破解 Kotlin 协程](https://zhuanlan.zhihu.com/p/114295411)
- [协程介绍](https://blog.csdn.net/huyongl1989/article/details/89287132)
- [掘金 协程](https://juejin.cn/post/6953287252373930021)
